# Documentation

## Links to Items within this Document

-   [Webpack Notes](#webpack-notes)
-   [Notifications Doc](#notifications-documentation)
-   [Suggestion Controller Doc](#suggestion-controller-documentation)
-   [User Code Execution Doc](#user-code-execution-documentation)
-   [Variable Controller Doc](#variable-controller-documentation)
-   [Toolbox.ts Doc](#toolbox-documentation)
-   [Typechecker Doc](#typechecker-documentation)
-   [Construct Events Doc](#construct-events-documentation)
-   [Miscellanious Doc](#misc-documentation)

## Dev Notes

### Webpack Notes

These are mainly notes on the fields within `webpack.config.js`. <br/>

-   **`entry`**: these are the various entries into the dependency graph that webpack uses to connect to other dependencies. Any new entry point needs to be added here.
    This is mostly for adding individual JS scripts since the rest of our code is added by the entry for `index.ts`. If you want to add a new script, you can just add the path
    to it inside the array under `app`. **Make sure to not add any scripts under a NEW entry. This will cause webpack to bundle multiple times which will end up running the code multiple times.**

-   **`output`**: this describes the path to the bundles generated by each entry point. If you want the bundles to be served from some other file or to rename them, this is the place to do it.

-   **`module: rules:`**: this lists how various file types are transpiled to code that can be ran by the browser. That's what the loaders are for. After adding a loader here, you need to
    specify what types of files it processes and then just install it through npm.

### Notifications Documentation

#### Notification.ts and NotificationController.ts

These two are pretty well documented inside the code. Notification.ts provides class definitions for all warnings that we have in the editor. This includes the draft mode. It also contains
the definition for `ConstructHighlight` an object that can be used to highlight a piece of code within the editor.

#### ErrorMsgGenerator.ts

This contains the old strings used for warning messages. Most of these are not used anymore, but they were left in the code in case some of the text can be used in the future.

### Suggestion Controller Documentation

Overall the way this works is you create a `Menu` object which holds `MenuOption` objects which perform some action when selected. `Menu` objects can be nested in a tree to provided nested menu functionality. `MenuController` is a singleton controlling all existing menus. It keeps track of open/closed menus as well as the currently focused option within each open menu.

If you want to create a menu you should use `MenuController`, you should not have to interact with `Menu` and `MenuOption` directly. So before modifying those, check if `MenuController` already provides the functionality you want and if it does not, it is likely that it should be added there rather than the menus and the options.

`Module` has a `MenuController` and that is how our code instantiates these menus. It calls `buldSingleLevelMenu()` each time a menu needs to be opened. If you want to see exactly how a menu is created by the calling code in various contexts, just search for usages of `buildSingleLevelMenu()`.

#### Menu

This is the main class that provides the functionality for our autocomplete and other menus. It can be used to create both a single-level and a tree menu. This only depends on how the menu
is built and the options are connected. This class also grants access to the DOM object of the menu as well as methods for manipulating it.

##### Attributes

-   **`options: MenuOption[]`**: <br/>
    List of MenuOption objects that are displayed by the menu.
-   **`editCodeActionsOptions: EditCodeAction[]`**: <br/>
    List of actions from which this menus options are created. These actions' `performAction` methods are executed when their
    corresponding option is selected in the menu.
-   **`openedLinkOptionIndex: number`**: <br/>
    Index into this.options of an option that is currently focused and links to another menu.
-   **`children: Menu[]`**: <br/>
    Stores all child menus of this menu. This allows the menus to be organized in a tree. This array should only be used to contain the next level of the tree, not all
    descendants of this menu.
-   **`parentMenu: Menu`**: <br/>
    The parent menu of this menu. The tree above it in the tree of menus. `null` if the current menu is a tree root.
-   **`htmlElement: HTMLDivElement`**: <br/>
    The menu DOM element to which option DOM elements are attached.
-   **`static menuCount: number`**: <br/>
-   **`static idPrefix: string`**: <br/>
    Used for numbering menus with unique IDs in the DOM in case the menus form a tree.

##### Behaviours

**1.** `constructor(options: Map<string, Function>)`

###### Summary:

###### Parameters:

-   **`options`**: </br> This map is expected to contain a mapping from option name to the action that is to be executed when the option is selected.

**2.** `closeChildren(): void`

###### Summary:

Close all open descendants of this menu if it has any.

**3.** `indentChildren(offset: number = 0): void`

###### Summary:

Indent all children of this menu according to their depth. This method visualizes the tree structure of the nested menus in the browser.

###### Parameters:

-   **`offset`**: <br/> Indentation value in px. All indents are made from left to right. If `offset > 0` this will be the initial offset used and the menus on the second level will appear that many px away from their parent. All subsequent menus will add to this offset. Keep this set to 0 if you want menus on each level to use their width as the indentation
    amount.

**4.** `linkMenuThroughOption(child: Menu, optionInParent: string): void`

###### Summary:

Link `this` and `child` together in a parent-child relationship such that when `optionInParent` is focused, it opens `child`. `optionInParent` is a string and so its
value is searched for inside the `options` array of this menu. This is for ease of use so that you don't need access to the menu option object itself when linking menus.

###### Parameters:

-   **`child`**: <br/> The menu to be opened when `optionInParent` is focused in this menu.
-   **`optionInParent`**: <br/> The text of the option to be used to link the two menus.

**5.** `removeChild(child: Menu): void`

###### Summary:

Remove a given child from the menu.

###### Parameters:

-   **`child`**: <br/>
    Child to be removed.

**6.** `static collapseSingleLinkMenus(root: Menu): void`

###### Summary:

Remove menu's that only serve as links (have a single option that links to another menu). In the example below option3 is not really necessary. These are the kinds of options this method will remove.

```
option1 --> option3 --> option4
option2
```

Will become

```
option1 --> option4
option2
```

###### Parameters:

-   **`root`**: the root of the menu structure

**7.** `removeEmptyChildren(): void`

###### Summary:

Remove all menus that are either completely empty or have options that don't perform any valid action. This is for cases such as the one below:

```
option1 --> option3 --> Empty Menu
option2     option4
```

Will become:

```
option1 --> option4
option2
```

**8.** `open(): void`

###### Summary:

Display this menu in the editor.

**9.** `close(): void`

###### Summary:

Hide this menu in the editor.

**10.** `isOpen(): boolean`

###### Summary:

Return whether this menu is currently visible in the editor or not.

**11.** `setChildMenus(menus: Menu[]): void`

###### Summary:

Replace this menus `children` list with `menus`.

###### Parameters:

-   **`menus`**: <br/> New menus that will be the children of this menu.

**12.** `addChildMenu(menu: Menu): void`

###### Summary:

Add a single child to this menu's children and update the parent of `menu` to be this.

###### Parameters:

-   **`menu`**: <br/> Menu that will become the child of `this`.

**13.** `removeFromDOM(): void`

###### Summary:

Remove this menu from the DOM.

**14.** `getOptionByText(optionText: string): MenuOption`

###### Summary:

Return the menu option with matching `optionText` within this menu's options. `undefined` if no options is found to have the given text.

###### Parameters:

-   **`optionText`**: <br/> Option text to match options on.

#### MenuOption

Provides the definition of our menu options. This are placed within menu objects and are displayed as part of the menu in the editor. These offer functionality for linking options
to other menus allowing the user code to nest menus.

##### Attributes

-   **`parentMenu: Menu`**: <br/>
    The menu within which this option is contained.
-   **`text: string`**: <br/>
    Display text of this option.
-   **`doc: ConstructDoc`**: <br/>
    Documentation object associated with this option.
-   **`htmlElement: HTMLDivElement`**: <br/>
    DOM element of this option.
-   **`selectAction: Function`**: <br/>
    Action performed when this option is selected, null if this option links to another menu.

##### Behaviours

**1.**

```
constructor(text: string = "Option Text",
        useInnerHTML: boolean = false,
        childMenu?: Menu,
        parentMenu?: Menu,
        doc?: ConstructDoc,
        selectAction?: Function,
        extraInformation?: string)
```

###### Summary:

###### Parameters:

-   **`text`**: </br>
    Option text that will be used by the option.
-   **`useInnerHTML`**: </br>
    Set to True if you want `text` to be treated as HTML by the option.
-   **`childMenu`**: </br>
    The menu object that this option links to. Allows this option to open sub menus when focused.
-   **`parentMenu`**: </br>
    The menu within which this option is contained.
-   **`doc`**: </br>
    Documentation object associated with this option.
-   **`selectAction`**: </br>
    Callback that runs when this option is clicked.
-   **`extraInformation`**: </br>
    Tooltip that appears next to the option name in the menu.

**2.** `select(): void`

###### Summary:

Either runs this option's `selectAction` or opens the sub menu attached to this option

**3.** `linkToChildMenu(child: Menu): void`

###### Summary:

Add a menu that will be open when this option is focused.

###### Parameters:

-   **`child`**: </br>
    Menu object representing the menu that will be opened when this option is focused.

**4.** `attachToParentMenu(menu: Menu): void`

###### Summary:

Attach this option to `menu` so that it is displayed as a potential selection in said menu.

###### Parameters:

-   **`menu`**: </br>
    The menu that will contain this option.

**5.** `hasChild(): boolean`

###### Summary:

Return whether this option has a menu that it links to.

**6.** `getChildMenu(): Menu `

###### Summary:

Return the child object that is linked to by this option.

**7.** `setFocus(): void`

###### Summary:

Update the visuals of this option to indicate that it has been focused.

**8** `removeFocus(): void`

###### Summary:

Update the visuals of this option to indicate that it is not focused.

**9** `removeFromDOM(): void`

###### Summary:

Remove the DOM element of this option from the DOM. **NOTE: This does not remove it from the menu that it was a part of on the backend. That has to be done manually.**

**10** `setChildMenu(child: Menu): void`

###### Summary:

Update the menu object that this option links to. The current menu that is being linked to, if there is one, will be replaced.

###### Parameters:

-   **`child`**: <br/>
    Menu to link to.

#### MenuController

This class provides the main control logic for creating and controlling a menu and its options. **Some parts of this class are documented within the code so this doc contains only those parts that are not documented in the code.**

##### Attributes

-   **`static suggestionOptionExtraInfo: string`**:
-   **`static optionElementClass: string`**:
-   **`static menuElementClass: string`**:
-   **`static optionTextElementClass: string`**:
-   **`static selectedOptionElementClass: string`**: <br/>
    These are all CSS class names used by the various elements of the menu.

-   **`module: Module`**: <br/>
    The global module instance of the entire program.

-   **`editor: Editor`**: <br/>
    The global editor instance of the entire program.

-   **`indexOfRootMenu: number`**: <br/>
    The index into `menus` indicating the location of the top-level menu. This is not necessarily always 0 for nested menus. It depends entirely on how it is constructed.

-   **`focusedMenuIndex: number`**: <br/>
    The index into `menus` of the currently open menu.

-   **`focusedOptionIndex: number`**: <br/>
    The index into `this.menus[this.focusedMenuIndex].options` indicating the location of the currently focused option within an open menu.

-   **`menus: Menu[]`**: <br/>
    The list of all menus currently controlled by this controller. Will usually contain a single element since we don't have nested menus anymore.

##### Behaviours

**1.** `static getInstance(): MenuController`

###### Summary:

`MenuController` is a singleton and this method should be used for obtaining its current instance. If not instance exists, a new one will be created.

**2.** `setInstance(module: Module, editor: Editor): void`

###### Summary:

Update the module and editor instances of the current `MenuController` instance.

###### Parameters:

-   **`module`**: <br/> Module object to use.
-   **`editor`**: <br/> Editor object to use.

**3.** `removeMenus(): void`

###### Summary:

Close and remove all menus from the MenuController (both backend and DOM removal). Completely clears the `menus` list.

**4.** `isMenuOpen(): boolean`

###### Summary:

Return whether the top-level menu of this controller is currently open and visible in the editor or not.

**5.** `updateMenuArrayFromTree(root: Menu, isRoot: boolean): void`

###### Summary:

Populate the `menus` list from a tree of menus.

###### Parameters:

-   **`root`**: <br/> The root of this menu.
-   **`isRoot`**: <br/> Whether `root` is the root of the overall menu tree. Should be false as long as `root.parentMenu` is not null.

**6.** `updateMenuOptions(optionText: string): void`

###### Summary:

Filter out options the text of which does not match optionText. Each menu has a list of edit actions originally associated with it. This function will filter those to only contain
options whose text most closely matches optionText.

###### Parameters:

-   **`optionText`**: <br/> Current user input from the AutocompleteTkn associated with this menu.

**7.** `updatePosition(pos: { left: number; top: number }): void`

###### Summary:

Set the position of the menu to `pos`.

###### Parameters:

-   **`pos`**: <br/> (x, y) position of the top left corner of the menu within the viewport.

**8.** `getNewMenuPosition(code: CodeConstruct): { left: number; top: number }`

###### Summary:

Update the position of the menu according to changes in the associated AutocompleteTkn. This ensures the menu moves to the end of the AutocompleteTkn as the user types.

###### Parameters:

-   **`code`**: `AutocompleteTkn` or other `CodeConstruct` to which the menu is attached.

### User Code Execution Documentation

To run the user code we are currently using `Pyodide` which enables us to run everything in the client's browser. Pyodide is loaded inside of `index.html` so if that ever needs to be updated just update the script tag inside of that file.
<br/>

The two scripts responsible for actually working with Pyodide are `load-pyodide.js` and `pyodide-controller.js`. The former simply loads Pyodide and exports the loaded object. **Note that this export is asynchronous and exports a Promise. See pyodide-controller.js for how to perform the corresponding import.**

#### Setting Pyodide Options

Inside of `load-pyodide.js` there is a method `loadPyodide()` which accepts an options object. Here is where you would set any of the options from the Pyodide docs. The most useful ones are overriding the behaviours of `stderr`, `stdin` and `stdout`. You can also set where Pyodide is loaded from here.

<br/>
Here is a sample: <br/>

```
loadPyodide({
   indexURL: "https://cdn.jsdelivr.net/pyodide/v0.18.0/full/",
   stdout: (text) => {
       addTextToConsole(text);
   },
})
```

#### Working with Pyodide

This is done in `pyodide-controller.js`. This script imports the Pyodide object loaded by `load-pyodide.js` and defines various useful functions for working with it. This module has one main anonymous function which contains the logic of using Pyodide. If you want to make any changes to the execution flow, here is the place. Here are some things that you might want to do with it:

-   **Running Python Code:** <br/>
    Simply call `pyodideControler.runPython()`. The first argument is a string with the code to be ran.

-   **Load JS functions into the user's Python script:** <br/>
    This can be done by simply adding the necessary functions to the `jsModule` object at the top of the script. This is already loaded into the Python script so all you have to do is use it inside the argument string to `runPython()`. See how the current input behaviour is modified for an example.

-   **Good to Know:**
    -   If you want to add another script, don't forget to add it to the bundle within `webpack.config.js`.
    -   The anonymous function is called immediately on script load.

### Variable Controller Documentation

This object deals with most variable-related logic such as determining variable type on a given line, finding references to a given variable, working with variable reference buttons in the toolbox, etc... It also deals with the creation and management of the cascaded menu.

##### Behaviours

**1.** `addVariableRefButton(assignmentStmt: VarAssignmentStmt)`

###### Summary:

Create a button within the toolbox's User-Defined Variables region for referencing the variable created with `assignmentStmt`.

###### Parameters:

-   **`assignmentStmt`**: <br/> Definition of the variable from which the reference button can be created.

**2.** `isVariableReferenceButton(buttonId: string): boolean`

###### Summary:

Return whether the DOM element with the id `buttonId` is a variable reference button or not.

###### Parameters:

-   **`buttonId`**: <br/> DOM id to search the variable reference buttons for.

**3.** `removeVariableRefButton(varId: string)`

###### Summary:

Remove the variable reference button with a given id from the DOM and internal storage.

###### Parameters:

-   **`varId`**: <br/> id of the button to remove. Should be `[VarAssignmentStmt Object].buttonId` unless the id is known from somewhere else.

**4.** `addWarningToVarRefs(varId: string, module: Module)`

###### Summary:

Highlight all references to the variable with id `varId` and provide a textual warning saying that all assingments of this variable have actually been deleted and therefore the variable cannot be referenced anymore. **Despite its name this method is only meant to be used SPECIFICALLY on variable references of variables that no longer exist.**

###### Parameters:

-   **`varId`**: <br/> the id of the variable the references to which should be highlighted.
-   **`module`**: <br/> module objects passed in so that the method may access the notification system to create the warning.

**5.** `getVariableButtons(): HTMLDivElement[]`

###### Summary:

Return the list of all variable reference buttons that currently exist. Not all of these are necessarily shown in the toolbox since the toolbox displays them based on context and scope.

**6.** `getVariableButton(varId: string): HTMLDivElement`

###### Summary:

Return the button associated with the variable with a given `varId` (`buttonId` if this comes from a `VarAssignmentStmt`).

###### Parameters:

-   **`varId`**: <br/> id of the button to search for.

**7.** `hideUnavailableVarsInToolbox(scope: Scope, lineNumber: number): void`

###### Summary:

Remove all reference buttons for variables that cannot be referenced in the current context from the "User-Defined Variables" area in the toolbox.

###### Parameters:

-   **`scope`**: <br/> The scope of the line that the cursor is currently on.
-   **`lineNumber`**: <br/> The line number of the line that the cursor is currently on. Any variable initialized below this line are considered to be unavailable.

**8.** `updateVarButtonWithType(buttonId: string, scope: Scope, lineNumber: number, identifier: string): void`

###### Summary:

Updates the variable reference button with the given id with a text displaying the type the associated variable would have at line `lineNumber`.

###### Parameters:

-   **`buttonId`**: <br/> id of the button/variable to determine the type of.
-   **`scope`**: <br/> The scope within which to search for the variable.
-   **`lineNumber`**: <br/> The line number at which to stop the search.
-   **`identifier`**: <br/> The identifier of the variable.

**9.** `getVariableTypeNearLine(scope: Scope, lineNumber: number, identifier: string, excludeCurrentLine: boolean = true): DataType`

###### Summary:

Return the type of the variable with the given `identifier` within the given `scope` and above line `lineNumber`. Can optionally include line `lineNumber` in the search by setting `excludeCurrentLine` to false.

###### Parameters:

-   **`scope`**: <br/> The current scope.
-   **`lineNumber`**: <br/> The line number at which to stop the search.
-   **`identifier`**: <br/> Identifier of the variable being searched for.

**10.** `getAllAssignmentsToVar(varId: string, module: Module): VarAssignmentStmt[]`

###### Summary:

Return a list of absolutely all assignments to the variable with id `varId` within the AST.

###### Parameters:

-   **`varId`**: <br/> ID of the variable to search for.
-   **`module`**: <br/> Module holding the AST to search in.
